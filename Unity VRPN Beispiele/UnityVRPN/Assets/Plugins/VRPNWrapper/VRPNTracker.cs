/* ========================================================================
 * PROJECT: UART
 * ========================================================================
 * Portions of this work are built on top of VRPN which was developed by
 *   Russell Taylor
 *   University of North Carolina
 * http://www.cs.unc.edu/Research/vrpn/
 *
 * We acknowledge the CISMM project at the University of North Carolina at Chapel Hill, supported by NIH/NCRR
 * and NIH/NIBIB award #2P41EB002025, for their ongoing  * support and maintenance of VRPN.
 *
 * Portions of this work are also built on top of the VideoWrapper,
 * a BSD licensed video access library for MacOSX and Windows.
 * VideoWrapper is available at SourceForge via 
 * http://sourceforge.net/projects/videowrapper/
 *
 * Copyright of VideoWrapper is
 *     (C) 2003-2010 Georgia Tech Research Corportation
 *
 * Copyright of the new and derived portions of this work
 *     (C) 2010 Georgia Tech Research Corporation
 *
 * This software released under the Boost Software License 1.0 (BSL1.0), so as to be 
 * compatible with the VRPN software distribution:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy 
 * of the software and accompanying documentation covered by this license (the "Software") to use, 
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative 
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant,
 * this restriction and the following disclaimer, must be included in all copies of the Software, in
 * whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
 * OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For further information regarding UART, please contact 
 *   Blair MacIntyre
 *   <blair@cc.gatech.edu>
 *   Georgia Tech, School of Interactive Computing
 *   85 5th Street NW
 *   Atlanta, GA 30308
 *
 * For further information regarding VRPN, please contact 
 *   Russell M. Taylor II
 *   <taylor@cs.unc.edu>
 *   University of North Carolina, 
 *   CB #3175, Sitterson Hall,
 *   Chapel Hill, NC 27599-3175
 *
 * ========================================================================
 ** @author   Alex Hill (ahill@gatech.edu)
 *
 * ========================================================================
 *
 * VRPNTracker.cs
 *
 * usage: Add this script to any GameObject to update its transform
 * 
 * inputs:
 * TrackerType   - VRPN tracker device name from configuration file
 * TrackerName   - name assigned to the device in its configuration line
 * SensorNumber  - index of sensor when configuration defines multiple
 * ApplyTracking - apply the current values from the sensor
 * Derivation    - derived data types are not applied to the transform
 * DeviceToUnity - transform between device coordinates and Unity coordinates
 * SensorOffset  - transform between tracker origin and sensor device
 * ShowDebug         - displays object name, position and orientation onscreen
 *
 * Notes:
 * the MotionNode console server must be manually started before use
 * see the installation documentation provided with MotionNode for details
 *
 * a configuration file is created at /tmp/vrpn.cfg using the given config file
 * the VRPNTrackerConfig.cs script is generated each execution to generate dropdown lists
 * play the scene twice to refresh lists after adding tracker names to the config file
 *
 * ========================================================================*/

using UnityEngine;
using System.Collections; 
using System;
using System.Runtime.InteropServices;

public class VRPNTracker : MonoBehaviour {
    
    // VRPN Tracker Report Structure   
	[ StructLayout( LayoutKind.Sequential, Pack=0 )] // set Pack=0 for Windows and Pack=1 for OSX
	public struct TrackerReport
	{
    	public VRPNManager.TimeVal msg_time;
     	public int sensor;
    	[ MarshalAs( UnmanagedType.ByValArray, SizeConst=3 )]
    	public double[] pos;
		[ MarshalAs( UnmanagedType.ByValArray, SizeConst=4 )]
    	public double[] quat;
 	}

    // Class Properties
	public static int num_trackers = 0;
	public enum Derivation_Type { None=1, Velocity=2, Acceleration=4 };          
	public enum Transform_Type { None=1, Position=2, Orientation=3, Both=4 }; 
        
    // Public Properties
    public VRPNManager.Tracker_Types TrackerType;
    //public VRPNDeviceConfig.Device_Names TrackerName;
	public string TrackerName = "Rigid Body 1";

    public Transform_Type ApplyTracking = Transform_Type.Both; 
    public Derivation_Type Derivation = Derivation_Type.None;  
    public Transform DeviceToUnity;
    public Transform SensorOffset;   
    public int SensorNumber = 0;
    public int MaxReports = 20;
    public bool ShowDebug = false;
    
    // Private Variables
	private bool initialized = false;
	private VRPNManager.TimeVal LastReport;
    private IntPtr[] repsPtr;
    
    private Vector3 lastPos = Vector3.zero;
    private Quaternion lastQuat = Quaternion.identity;
    private Vector3 trackerPos = Vector3.zero;
    private Quaternion trackerQuat = Quaternion.identity;
    private Vector3 pos = Vector3.zero;
    private Quaternion quat = Quaternion.identity;
    
	private string debug_text = "";
	private int debug_xoffset;
	
	public Vector3 GetPosition()
	{
		return trackerPos;
	}

	public Quaternion GetRotation()
	{
		return trackerQuat;
	}
	
    [DllImport ("VRPNWrapper")]
    private static extern void VRPNTrackerStart(string name, int deriv);

    void Start () {
    	//allocate unmanaged memory for tracker reports
		repsPtr = new IntPtr[MaxReports];
		TrackerReport report = new TrackerReport();
		report.sensor = 0;
     	report.pos = new double[3];
     	report.quat = new double[4];
		report.quat[3] = 1.0f;
		for(int i=0; i<MaxReports ; i++)
		{
			repsPtr[i] = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(TrackerReport)));
			Marshal.StructureToPtr(report, repsPtr[i], true);
		}
    	if (DeviceToUnity == null || SensorOffset == null)
    	{
    		if (DeviceToUnity == null)
    			Console.WriteLine("Warning: DeviceToUnity field not referencing a transform");
    		if (SensorOffset == null)
    			Console.WriteLine("Warning: SensorOffset field not referencing a transform");
    	}
        
        // Setup last report time memory 
		LastReport = new VRPNManager.TimeVal();  
    }
    
    bool StartTracker () { 	
        if (VRPNManager.initialized)
        {
            // Register Tracker Device
            VRPNTrackerStart(TrackerName.ToString(),(int)Derivation);
            num_trackers++;
            
            // Set up debug window
            if (ShowDebug)
            {
                debug_xoffset = num_trackers*210;
                if (VRPNManager.debug_flag)
                    debug_xoffset += 405;
            }
            initialized = true;
            return true;
        }
        return false;
    }

    void Update () {
        // Ensure device is ready
        if (!initialized && !StartTracker()) return;
    
    	GetLatestPosQuat();
    	//GetAveragePosQuat();
    	if (TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_GPS)
    	{
    		Vector3 tmp = trackerPos;
	    	trackerPos.x = tmp[1];
  		  	trackerPos.y = tmp[2];
    		trackerPos.z = tmp[0];
    	}
		if (ApplyTracking == Transform_Type.Both)
		{
			pos = trackerPos;
			lastPos = pos;
			quat = trackerQuat;
			lastQuat = quat;
		}
		else if (ApplyTracking == Transform_Type.Position)
		{
			pos = trackerPos;
			lastPos = pos;
			quat = lastQuat;
		}
		else if (ApplyTracking == Transform_Type.Orientation)
		{
			pos = lastPos;
			quat = trackerQuat;
			lastQuat = quat;
		}
 		else
		{
			pos = lastPos;
			quat = lastQuat;
		}
		//update transform if using no Derivation
    	if (Derivation == Derivation_Type.None) {
    		if (DeviceToUnity != null)
    		{
    			//update the transform with the position and orientation of the tracker
    			pos = DeviceToUnity.InverseTransformPoint(pos);
    	    	if ( TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_GPS )
    	    	{
    				Vector3 scale = LatLongToMeter(DeviceToUnity.localPosition.z);
    				pos[0] *= scale[0];
    				pos[2] *= scale[2];
    	    	}
				quat = Quaternion.Inverse(DeviceToUnity.localRotation) * quat;
    			if (SensorOffset != null)
    			{
					Matrix4x4 mat = Matrix4x4.TRS(pos,quat,Vector3.one) * SensorOffset.worldToLocalMatrix;
					pos = mat.GetColumn(3);
    				quat = QuaternionFromMatrix(mat);
    			}
            //Debug.Log(pos);   
			UpdateTransform(pos, quat);
    		}
    	}
    	if (ShowDebug) {
    		debug_text = this.name + 
    					System.String.Format("\nPOS[X:{0:F2},Y:{1:F2},Z:{2:F2}]", pos.x, pos.y, pos.z) + 
    					System.String.Format("\nORI[X:{0:F2},Y:{1:F2},Z:{2:F2}]", quat.eulerAngles[0], quat.eulerAngles[1], quat.eulerAngles[2]);
    	}	
    }
    
    protected virtual void UpdateTransform(Vector3 pos, Quaternion quat)
    {
    
   		if (ApplyTracking == Transform_Type.Both || ApplyTracking == Transform_Type.Position)
        {       
            transform.localPosition = pos;   
        }         
   		if (ApplyTracking == Transform_Type.Both || ApplyTracking == Transform_Type.Orientation)
   			transform.localRotation = quat;
    }

	void OnGUI () {
		if (ShowDebug) {
			GUI.skin.box.alignment = TextAnchor.LowerLeft;
			GUI.Box(new Rect(debug_xoffset + 10, 10, 200, 45), debug_text);		
		}
	}
	
    [DllImport ("VRPNWrapper")]
    private static extern void VRPNTrackerPosReport(string name, [In,Out] IntPtr rep, [Out] IntPtr ts, int sensor);

	void GetLatestPosQuat()
    {        
		VRPNTrackerPosReport(TrackerName.ToString(),repsPtr[0],IntPtr.Zero,SensorNumber);
        if(ShowDebug)
        {
            //Debug.Log(repsPtr[0].ToString());
        }
		TrackerReport rep = (TrackerReport)Marshal.PtrToStructure(repsPtr[0],typeof(TrackerReport));
	    trackerPos.x = (float)rep.pos[0];
  		trackerPos.y = (float)rep.pos[1];
    	trackerPos.z = (float)rep.pos[2];
        if(ShowDebug)
        {
            //Debug.Log(rep.pos[0]+";"+rep.pos[1]+";"+rep.pos[2]);
        }
    	trackerQuat.x = (float)rep.quat[2];	
    	trackerQuat.y = -(float)rep.quat[1];	
    	trackerQuat.z = (float)rep.quat[0];	
    	trackerQuat.w = (float)rep.quat[3];
		LastReport.tv_sec = rep.msg_time.tv_sec;
		LastReport.tv_usec = rep.msg_time.tv_usec;
	}	
	
    [DllImport ("VRPNWrapper")]
    private static extern int VRPNTrackerNumPosReports(string name);

    [DllImport ("VRPNWrapper")]
    private static extern void VRPNTrackerPosReports(string name, [In,Out] IntPtr[] repsPtr, [In,Out] ref int nmbr);

	void GetAveragePosQuat()
	{
		int num = MaxReports;
		VRPNTrackerPosReports(TrackerName.ToString(),repsPtr,ref num);
		float[] repsSum = new float[7];
		int repsCount = 0;
		TrackerReport[] reps = new TrackerReport[num];
		for (int i=0; i<num; i++)
			{
			reps[i] = (TrackerReport)Marshal.PtrToStructure(repsPtr[i],typeof(TrackerReport));
			if (reps[i].sensor == SensorNumber && VRPNManager.TimeValGreater(ref reps[i].msg_time,ref LastReport))
			{
				repsSum[0] += (float)reps[i].pos[0];
				repsSum[1] += (float)reps[i].pos[1];
				repsSum[2] += (float)reps[i].pos[2];
				repsSum[3] += (float)reps[i].quat[2];	
				repsSum[4] += -(float)reps[i].quat[1];	
				repsSum[5] += (float)reps[i].quat[0];	
				repsSum[6] += (float)reps[i].quat[3];
				LastReport.tv_sec = reps[i].msg_time.tv_sec;
				LastReport.tv_usec = reps[i].msg_time.tv_usec;
				repsCount++;
			}
		}
		if (repsCount > 0)
		{
		    trackerPos.x = repsSum[0]/(float)repsCount;
	  		trackerPos.y = repsSum[1]/(float)repsCount;
	    	trackerPos.z = repsSum[2]/(float)repsCount;
	    	trackerQuat.x = repsSum[3]/(float)repsCount;	
	    	trackerQuat.y = repsSum[4]/(float)repsCount;	
	    	trackerQuat.z = repsSum[5]/(float)repsCount;	
	    	trackerQuat.w = repsSum[6]/(float)repsCount;
		}
		else
		{
			trackerPos = lastPos;
			trackerQuat = lastQuat;
		}
	}
	
	Vector3 LatLongToMeter(float latitude) 
	{
		// Convert latitude to radians
	 	Vector3 result = Vector3.one;
		double lat = (latitude * 2.0 * Math.PI)/360.0;

		// Set up "Constants"
		double m1 = 111132.92;		// latitude calculation term 1
		double m2 = -559.82;		// latitude calculation term 2
		double m3 = 1.175;			// latitude calculation term 3
		double m4 = -0.0023;		// latitude calculation term 4
		double p1 = 111412.84;		// longitude calculation term 1
		double p2 = -93.5;			// longitude calculation term 2
		double p3 = 0.118;			// longitude calculation term 3

		// Calculate the length of a degree of latitude and longitude in meters
		double latlen = m1 + (m2 * Math.Cos(2 * lat)) + (m3 * Math.Cos(4 * lat)) + (m4 * Math.Cos(6 * lat));
		double longlen = (p1 * Math.Cos(lat)) + (p2 * Math.Cos(3 * lat)) + (p3 * Math.Cos(5 * lat));
					
	 	result.x = (float)longlen;
	 	result.z = (float)latlen;
	 	return result;
	}
	
    public static Quaternion QuaternionFromMatrix(Matrix4x4 m) 
    {
      // Adapted from: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
      Quaternion q = new Quaternion();
      q.w = Mathf.Sqrt( Mathf.Max( 0, 1 + m[0,0] + m[1,1] + m[2,2] ) ) / 2;
      q.x = Mathf.Sqrt( Mathf.Max( 0, 1 + m[0,0] - m[1,1] - m[2,2] ) ) / 2;
      q.y = Mathf.Sqrt( Mathf.Max( 0, 1 - m[0,0] + m[1,1] - m[2,2] ) ) / 2;
      q.z = Mathf.Sqrt( Mathf.Max( 0, 1 - m[0,0] - m[1,1] + m[2,2] ) ) / 2;
      q.x *= Mathf.Sign( q.x * ( m[2,1] - m[1,2] ) );
      q.y *= Mathf.Sign( q.y * ( m[0,2] - m[2,0] ) );
      q.z *= Mathf.Sign( q.z * ( m[1,0] - m[0,1] ) );
      return q;
   }

}
