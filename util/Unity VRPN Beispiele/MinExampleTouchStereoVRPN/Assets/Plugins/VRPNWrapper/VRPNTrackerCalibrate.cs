/* ========================================================================
 * PROJECT: UART
 * ========================================================================
 * Portions of this work are built on top of VRPN which was developed by
 *   Russell Taylor
 *   University of North Carolina
 * http://www.cs.unc.edu/Research/vrpn/
 *
 * We acknowledge the CISMM project at the University of North Carolina at Chapel Hill, supported by NIH/NCRR
 * and NIH/NIBIB award #2P41EB002025, for their ongoing  * support and maintenance of VRPN.
 *
 * Portions of this work are also built on top of the VideoWrapper,
 * a BSD licensed video access library for MacOSX and Windows.
 * VideoWrapper is available at SourceForge via 
 * http://sourceforge.net/projects/videowrapper/
 *
 * Copyright of VideoWrapper is
 *     (C) 2003-2010 Georgia Tech Research Corportation
 *
 * Copyright of the new and derived portions of this work
 *     (C) 2010 Georgia Tech Research Corporation
 *
 * This software released under the Boost Software License 1.0 (BSL1.0), so as to be 
 * compatible with the VRPN software distribution:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy 
 * of the software and accompanying documentation covered by this license (the "Software") to use, 
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative 
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant,
 * this restriction and the following disclaimer, must be included in all copies of the Software, in
 * whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
 * OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For further information regarding UART, please contact 
 *   Blair MacIntyre
 *   <blair@cc.gatech.edu>
 *   Georgia Tech, School of Interactive Computing
 *   85 5th Street NW
 *   Atlanta, GA 30308
 *
 * For further information regarding VRPN, please contact 
 *   Russell M. Taylor II
 *   <taylor@cs.unc.edu>
 *   University of North Carolina, 
 *   CB #3175, Sitterson Hall,
 *   Chapel Hill, NC 27599-3175
 *
 * ========================================================================
 ** @author   Alex Hill (ahill@gatech.edu)
 *
 * ========================================================================
 *
 * VRPNTrackerCalibrate.cs
 *
 * usage: Add this script to any VRPNTracker to calibrate its transform
 * 
 * inputs:
 *
 * Notes:
 *
 * ========================================================================*/

using UnityEngine;
using System;

public class VRPNTrackerCalibrate : MonoBehaviour {
    
	private enum Action_Type { None, FieldOfView, Rotate, XYAxis, XZAxis };          

	private Action_Type state;
	private string label_text1 = 
	"\tSelect\tSave\t\tReset\tGain+\tGain-\n" +
	"\t8\t\t\t9\t\t\t0\t\t\t-\t\t\t+\n" +
	"\tI\t\t\tO\t\t\tP\t\t\t[\t\t\t";

	private int index;
	private int last_global_index = 0;
	public static int global_index = 0;
	public static int global_count = 0;
    private Vector3 sensorPosition;
    private Quaternion sensorRotation;
    private Vector3 trackerPosition;
    private Quaternion trackerRotation;
    public static float fieldOfView;
    private Transform plane;
	private int gain = 1;
	private VRPNTracker tracker;
    private string[] state_string;
    private bool savedDebug;
    private VRPNTracker.Transform_Type savedApply;

    void Start () {
    	index = global_count;
    	global_count++;
    	global_index = global_count;
    	state_string = new string[4];
    	state_string[0] = "fov";
    	state_string[1] = "rotate";
    	state_string[2] = "xy";
    	state_string[3] = "xz";
		tracker = (VRPNTracker)GetComponent(typeof(VRPNTracker));
    	sensorPosition = tracker.SensorOffset.localPosition;
    	sensorRotation = tracker.SensorOffset.localRotation;
    	if (Camera.main == null)
    		Debug.Log("No camera found");
    	else
    	{
    		fieldOfView = Camera.main.fieldOfView;
    		Component planeRender = GetComponentInChildren(typeof(Renderer));
    		if (planeRender != null)
    			plane = planeRender.gameObject.transform;
    	}
    	if (tracker == null)
    		Debug.Log("No tracker found");
    	else
    		{
    		savedApply = tracker.ApplyTracking;
    		savedDebug = tracker.ShowDebug;
    		}
    }

    void Update () {
    	//avoid capturing key events twice
    	if (global_index != last_global_index)
    	{
    		last_global_index = global_index;
    		return;
    	}
    	if (index == global_index || (index == global_count-1 && global_index == global_count))
    	{
    		//Select Tracker
    		if (Input.GetKeyDown(KeyCode.Alpha8))
    		{
    			global_index++;
    			if (global_index > global_count)
    				global_index = 0;
    			tracker.ApplyTracking = savedApply;
    			tracker.ShowDebug = savedDebug;
    		}
    	}
 	   	if (index == global_index && tracker != null)
    	{
    		Action_Type priorState = state;
    		//Save to prefab
    		if (Input.GetKeyDown(KeyCode.Alpha9))
    		{
    			sensorPosition = tracker.SensorOffset.localPosition;
    			sensorRotation = tracker.SensorOffset.localRotation;
    			if (Camera.main != null)
    				fieldOfView = Camera.main.fieldOfView;
    		}
    		else if (Input.GetKeyDown(KeyCode.Alpha0))
    		{
    			tracker.SensorOffset.localPosition = sensorPosition;
    			tracker.SensorOffset.localRotation = sensorRotation;
    			if (Camera.main != null)
    				Camera.main.fieldOfView = fieldOfView;
    		}
    		else if (Input.GetKeyDown(KeyCode.Minus))
    		{
    			gain -= 1;
    			if (gain <= 0)
    				gain = 1;
    		}
    		else if (Input.GetKeyDown(KeyCode.Equals))
    		{
    			gain += 1;
    		}
    		else if (Input.GetKeyDown(KeyCode.I))
    		{
    			if (state == Action_Type.FieldOfView)
    				state = Action_Type.None;
    			else
    				state = Action_Type.FieldOfView;
    		}
    		else if (Input.GetKeyDown(KeyCode.O))
    		{
    			if (state == Action_Type.Rotate)
    				state = Action_Type.None;
    			else
    				state = Action_Type.Rotate;
    		}
    		else if (Input.GetKeyDown(KeyCode.P))
    		{
    			if (state == Action_Type.XYAxis)
    				state = Action_Type.None;
    			else
    				state = Action_Type.XYAxis;
    		}
			else if (Input.GetKeyDown(KeyCode.LeftBracket))
    		{
    			if (state == Action_Type.XZAxis)
    				state = Action_Type.None;
    			else
    				state = Action_Type.XZAxis;
    		}
    		if (priorState == Action_Type.None && (int)state > 0)
    		{
    			savedApply = tracker.ApplyTracking;
    			savedDebug = tracker.ShowDebug;
    			if (tracker.TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_MotionNode)
    				tracker.ApplyTracking = VRPNTracker.Transform_Type.None;
    			trackerPosition = tracker.GetPosition();
    			trackerRotation = tracker.GetRotation();
    			tracker.ShowDebug = true;
    		}
    		else if (state != priorState)
    		{
    			tracker.ApplyTracking = savedApply;
    			tracker.ShowDebug = savedDebug;
    		}
    		if (state == Action_Type.FieldOfView)
    		{
   				float fov = Camera.main.fieldOfView;
   				fov += gain*0.01f*Input.GetAxis("Mouse X");
   				if (Camera.main != null)
   					{
   					Camera.main.fieldOfView = fov;
   					if (plane != null)
   						{
   						Vector3 pos = plane.localPosition;
   						pos.z = (float)(5.0*plane.localScale.z/Math.Tan(Math.PI*(double)fov/360.0f));
   						plane.localPosition = pos;
   						}
   					}
    		}
    		else if (state == Action_Type.Rotate)
    		{
    			if (tracker.TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_MotionNode)
    			{
    				tracker.SensorOffset.localRotation = Quaternion.Inverse(trackerRotation)*tracker.GetRotation();
    				tracker.SensorOffset.localRotation *= sensorRotation;
    			}
    			else
    			{
    				Vector3 right = tracker.SensorOffset.localRotation * Vector3.right;
    				Vector3 up = tracker.SensorOffset.localRotation * Vector3.up;
    				Quaternion mouseXRotation = Quaternion.AngleAxis(-gain*0.01f*Input.GetAxis("Mouse X"),up);
    				Quaternion mouseYRotation = Quaternion.AngleAxis(-gain*0.01f*Input.GetAxis("Mouse Y"),right);
    				tracker.SensorOffset.localRotation *= mouseXRotation * mouseYRotation;
    			}
    		}
    		else if (state == Action_Type.XYAxis)
    		{
    			if (tracker.TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_MotionNode)
    			{
    				Vector3 pos = tracker.SensorOffset.localPosition;
    				pos.x += gain*0.01f*Input.GetAxis("Mouse X");
    				pos.y += gain*0.01f*Input.GetAxis("Mouse Y");
    				tracker.SensorOffset.localPosition = pos;
    			}
    			else
    				tracker.SensorOffset.localPosition = tracker.GetPosition() - trackerPosition;
    		}
    		else if (state == Action_Type.XZAxis)
    		{
    			if (tracker.TrackerType == VRPNManager.Tracker_Types.vrpn_Tracker_MotionNode)
    			{
    				Vector3 pos = tracker.SensorOffset.localPosition;
    				pos.x += gain*0.01f*Input.GetAxis("Mouse X");
    				pos.z += gain*0.01f*Input.GetAxis("Mouse Y");
    				tracker.SensorOffset.localPosition = pos;
    			}
    			else
    				tracker.SensorOffset.localPosition = tracker.GetPosition() - trackerPosition;
    		}
    	}
    }

	void OnGUI () {
		if (index == global_index) {
			for (int i=0; i<4; i++)
			{
				if ((int)state == i+1)
					state_string[i] = state_string[i].ToUpper();
				else
					state_string[i] = state_string[i].ToLower();
			}
			GUI.skin.box.alignment = TextAnchor.LowerLeft;
			string debug_text = "Tracker: " + gameObject.name + " SensorOffset: " + 
								tracker.SensorOffset.gameObject.name + "\n" + label_text1 +
								gain.ToString() + "\n" +
								"\t" + state_string[0] + "\t\t" + state_string[1] + 
								"\t" + state_string[2] + "\t\t" + state_string[3] + "\n";			
			GUI.Box(new Rect(Screen.width/2-150, Screen.height-100, 350, 90), debug_text);		
			if (state == Action_Type.FieldOfView)
			{
	    		int debug_xoffset = VRPNTracker.num_trackers*210;
	    		if (VRPNManager.debug_flag)
	    			debug_xoffset += 405;
				string debug_text2;
				if (Camera.main != null)
				{
					debug_text2 = Camera.main.name + 
									System.String.Format("\nFOV[{0:F2}]\n", Camera.main.fieldOfView);
					if (plane != null)
						debug_text2 += System.String.Format("PLANE[{0:F2}]", plane.localPosition.z);
				}						
				else
					debug_text2 = Camera.main.name + "\nNo Camera Found\n";
				GUI.skin.box.alignment = TextAnchor.LowerLeft;
				GUI.Box(new Rect(debug_xoffset + 10, 10, 200, 45), debug_text2);	
			}	
		}
	}
	
}
